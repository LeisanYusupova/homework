//1.Метод запроса OPTIONS используется для определения возможностей сервера или параметров соединения для ресурса, доступного по определенному URL. Когда клиент отправляет запрос OPTIONS, сервер может возвращать информацию о поддерживаемых методах запроса, поддерживаемых заголовках, или других характеристиках ресурса. Это позволяет клиенту определить, какие действия он может выполнять с использованием данного ресурса, не осуществляя фактического запроса.
//
// Основные характеристики метода OPTIONS:
//
// Когда вызывается: OPTIONS-запрос может быть отправлен в любое время, чтобы запросить информацию о ресурсе перед тем, как отправить более конкретный запрос. Например, это может быть полезно для проверки кросс-доменных запросов (CORS) и предотвращения проблем безопасности.
//
// Где используется: Метод OPTIONS широко применяется в контексте веб-разработки, особенно в рамках протокола HTTP/1.1. Он может использоваться в сочетании с CORS для определения, разрешено ли клиенту отправлять запросы на сервер в другом домене.
//
// Что передает и принимает: Запрос OPTIONS не содержит тела (body), и он используется для запроса информации о сервере или ресурсе. Ответ от сервера содержит информацию о поддерживаемых методах, заголовках, возможностях или других параметрах, связанных с ресурсом.

//2.Прочитать и описать ключевые особенности "HTTP" Версии 3.0
// Транспорт через QUIC: Одной из главных особенностей HTTP/3 является использование протокола QUIC в качестве транспортного уровня. QUIC (Quick UDP Internet Connections) разрабатывался Google и предоставляет транспорт поверх протокола UDP. Это позволяет избежать ограничений, связанных с TCP, и улучшает производительность при передаче данных.
//
// Мультиплексирование потоков: Как и в HTTP/2, HTTP/3 поддерживает мультиплексирование потоков, что означает, что несколько запросов и ответов могут передаваться одновременно по одному соединению. Это улучшает эффективность использования ресурсов и ускоряет передачу данных.
//
// Плавающий заголовок (Header Compression): HTTP/3 также использует сжатие заголовков, но сейчас оно реализовано с использованием более эффективного алгоритма QPACK. Это позволяет сжимать заголовки более эффективно и снижает накладные расходы на передачу заголовков.
//
// Поддержка "нулевого-RTT" (Zero Round Trip Time Resumption): HTTP/3 поддерживает возможность восстановления соединения с сервером без ожидания раунд-трипа (RTT). Это снижает задержки при установке нового соединения.
//
// Улучшенные механизмы обнаружения и восстановления от ошибок: HTTP/3 включает в себя улучшенные механизмы обнаружения и восстановления от ошибок, что делает протокол более устойчивым к проблемам в сети.
//
// Концепция потоков данных: HTTP/3 интегрирует концепцию потоков данных, которая упрощает взаимодействие между клиентом и сервером. Это улучшает производительность и снижает задержки.
//
// Обратная совместимость: Одним из важных принципов HTTP/3 является обратная совместимость. Это означает, что при наличии HTTP/3 клиент и сервер, они могут взаимодействовать с ресурсами, которые поддерживают предыдущие версии HTTP.
//
// HTTP/3 представляет собой важный шаг вперёд в развитии протокола HTTP, улучшая производительность и эффективность передачи данных в условиях современного интернета. Однако, при использовании новых технологий, важно следить за обновлениями и применять их в соответствии с актуальными требованиями и стандартами.

//3.Один из современных методов для отмены запросов - использование объекта AbortController в сочетании с методом AbortSignal. Этот механизм позволяет создавать сигналы отмены и связывать их с запросами.
const abortController = new AbortController();
const abortSignal = abortController.signal;
const url = 'https://api.example.com/data';
const options = {
    method: 'GET',
    signal: abortSignal, // Передача сигнала отмены в параметрах запроса
};

const request = fetch(url, options);
abortController.abort(); // Вызов метода abort() отменит запрос, связанный с контроллером
//Этот вызов приведет к генерации события 'abort' на объекте AbortSignal. Вы можете подписаться на это событие, чтобы выполнить дополнительные действия в случае отмены запроса.
abortSignal.addEventListener('abort', () => {
    console.log('Запрос был отменен.');
});
//Использование AbortController позволяет более гибко управлять отменой запросов, особенно в сценариях, где необходимо прерывать запросы по требованию пользователя или в ответ на изменение состояния приложения.
//4.Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)
const strLiteral = 'Привет, мир!';
const strObject = new String('Еще одна строка');


const numLiteral = 42;
const numObject = new Number(3.14);
const num3 = +'3'

const boolLiteral = true;
const boolObject = new Boolean(false);

const nullValue = null;
const explicitNull = Object.create(null);

let undefinedValue; // не присвоено значение, поэтому undefined
const explicitUndefined = undefined;

const symbolOne = Symbol('описание для символа 1');
const symbolTwo = Symbol('описание для символа 2');

const bigIntLiteral = 123n;
const bigIntObject = BigInt(456);

//5.Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?
//JavaScript поддерживает поднятие (hoisting) переменных, но не инициализацию. Поднятие переменных означает, что объявления переменных перемещаются в начало своей области видимости в процессе компиляции кода. Однако их инициализация остается на месте.
//
// Когда мы пытаемся обратиться к переменной до ее объявления с использованием let и const, JavaScript поднимет только объявление переменной, но не ее инициализацию. В результате, переменная будет существовать, но попытка обратиться к ней до ее объявления приведет к ReferenceError.

//6.
const res = "B" + "a" + (1 - "hello");
console.log(res); //BaNaN

const res2 = (true && 3) + "d";
console.log(res2); //3d

const res3 = Boolean(true && 3) + "d";
console.log(res3); //trued