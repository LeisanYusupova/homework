//1) Какие бывают алгоритмы сортировок ?

// - Сортировка пузырьком:
//     Проходит по списку многократно, сравнивая пару соседних элементов и меняя их местами, если они находятся в неправильном порядке
//
// - Сортировка выбором:
//     Находит минимальный элемент из списка и помещает его в начало списка. Затем делает то же самое для остальных элементов, смещая минимальный из оставшихся в начало списка
//
// - Сортировка слиянием:
//     Разделяет список на две части, сортируя каждую отдельно, затем сливаем два отсортированных списка в один
//
// - Быстрая сортировка:
//     Выбирает один элемент (как опорный элемент) и разделяет список на две части, все элементы, которое меньше опорного элемента в одну часть списка, остальные в противоположную часть списка. Затем с помощью рекурсии продолжает то же самое к получившимся спискам

//3)Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.

//Литеральный синтаксис объекта:
const Person = {
    name: 'Jack',
    age: 25,
};

//Класс
// class Person {
//     constructor(name, age) {
//         this.name = name;
//         this.age = age;
//     }
// }

//Функция-конструктор:
// function Person(name, age) {
//     this.name = name;
//     this.age = age;
// }
//

const Person2 = Object.create(Person);

//действует протоптипное наследование
Person.logInfo = function() {
    console.log(`Name: ${this.name}, Age: ${this.age}`);
};



//4 задание

class Person {
    constructor(name) {
        this._name = name;
    }

    get name() {
        return this._name;
    }

    set name(newName) {
        this._name = newName;
    }
}

// Класс PersonThree наследует функциональность класса Person
class PersonThree extends Person {
    constructor(name, age) {
        super(name);
        this.age = age;
    }
}

//5 задание

const firstSum = (arr, total) => {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] + arr[j] === total) {
                return [arr[i], arr[j]];
            }
        }
    }
    return null; // Если такая пара не найдена
};
//Квадратичная сложность